"""
Signal generation data structures for trading strategies.

This module defines the data models for trading signals generated by strategies.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional, Dict, Any


class SignalType(Enum):
    """Types of trading signals."""
    ENTRY_LONG = "ENTRY_LONG"
    ENTRY_SHORT = "ENTRY_SHORT"
    EXIT_LONG = "EXIT_LONG"
    EXIT_SHORT = "EXIT_SHORT"
    HOLD = "HOLD"


class SignalStrength(Enum):
    """Signal strength levels."""
    WEAK = "WEAK"
    MODERATE = "MODERATE"
    STRONG = "STRONG"


@dataclass
class TradingSignal:
    """
    Trading signal generated by a strategy.
    
    Attributes:
        signal_type: Type of signal (entry/exit, long/short)
        instrument: Trading symbol
        timestamp: When the signal was generated
        price: Price at which signal was generated
        strength: Signal strength indicator
        strategy_name: Name of the strategy that generated the signal
        reason: Human-readable reason for the signal
        metadata: Additional signal-specific data
        confidence: Confidence level (0-1)
    """
    signal_type: SignalType
    instrument: str
    timestamp: datetime
    price: float
    strength: SignalStrength
    strategy_name: str
    reason: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)
    confidence: float = 0.5
    
    def __post_init__(self):
        """Validate signal data after initialization."""
        if self.price <= 0:
            raise ValueError(f"Invalid price: {self.price}. Must be positive.")
        if not 0 <= self.confidence <= 1:
            raise ValueError(f"Invalid confidence: {self.confidence}. Must be between 0 and 1.")
        if not self.instrument:
            raise ValueError("Instrument cannot be empty.")
        if not self.strategy_name:
            raise ValueError("Strategy name cannot be empty.")
    
    def is_entry_signal(self) -> bool:
        """Check if this is an entry signal."""
        return self.signal_type in [SignalType.ENTRY_LONG, SignalType.ENTRY_SHORT]
    
    def is_exit_signal(self) -> bool:
        """Check if this is an exit signal."""
        return self.signal_type in [SignalType.EXIT_LONG, SignalType.EXIT_SHORT]
    
    def is_long_signal(self) -> bool:
        """Check if this is a long (buy) signal."""
        return self.signal_type in [SignalType.ENTRY_LONG, SignalType.EXIT_SHORT]
    
    def is_short_signal(self) -> bool:
        """Check if this is a short (sell) signal."""
        return self.signal_type in [SignalType.ENTRY_SHORT, SignalType.EXIT_LONG]
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary representation."""
        return {
            'signal_type': self.signal_type.value,
            'instrument': self.instrument,
            'timestamp': self.timestamp.isoformat(),
            'price': self.price,
            'strength': self.strength.value,
            'strategy_name': self.strategy_name,
            'reason': self.reason,
            'metadata': self.metadata,
            'confidence': self.confidence,
        }


@dataclass
class StrategyParameters:
    """
    Configuration parameters for a trading strategy.
    
    Attributes:
        lookback_period: Number of periods to look back for calculations
        entry_threshold: Threshold value for entry signals
        exit_threshold: Threshold value for exit signals
        stop_loss_pct: Stop loss percentage
        take_profit_pct: Take profit percentage
        min_confidence: Minimum confidence level for signals
        custom_params: Strategy-specific custom parameters
    """
    lookback_period: int = 20
    entry_threshold: float = 0.0
    exit_threshold: float = 0.0
    stop_loss_pct: float = 2.0
    take_profit_pct: float = 5.0
    min_confidence: float = 0.5
    custom_params: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate parameters after initialization."""
        if self.lookback_period <= 0:
            raise ValueError(f"Invalid lookback_period: {self.lookback_period}. Must be positive.")
        if self.stop_loss_pct < 0:
            raise ValueError(f"Invalid stop_loss_pct: {self.stop_loss_pct}. Must be non-negative.")
        if self.take_profit_pct < 0:
            raise ValueError(f"Invalid take_profit_pct: {self.take_profit_pct}. Must be non-negative.")
        if not 0 <= self.min_confidence <= 1:
            raise ValueError(f"Invalid min_confidence: {self.min_confidence}. Must be between 0 and 1.")
    
    def get_param(self, key: str, default: Any = None) -> Any:
        """Get a custom parameter value."""
        return self.custom_params.get(key, default)
    
    def set_param(self, key: str, value: Any) -> None:
        """Set a custom parameter value."""
        self.custom_params[key] = value
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert parameters to dictionary representation."""
        return {
            'lookback_period': self.lookback_period,
            'entry_threshold': self.entry_threshold,
            'exit_threshold': self.exit_threshold,
            'stop_loss_pct': self.stop_loss_pct,
            'take_profit_pct': self.take_profit_pct,
            'min_confidence': self.min_confidence,
            'custom_params': self.custom_params,
        }
